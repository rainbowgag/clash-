<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>Dialer é“¾å¼èŠ‚ç‚¹ç”Ÿæˆå™¨</title>

<style>
body {
  font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto;
  background:#f0f2f5;
  padding:20px;
}
h1 { text-align:center; margin-bottom:30px; }
.section {
  background:#fff;
  padding:20px;
  margin-bottom:20px;
  border-radius:12px;
  box-shadow:0 8px 24px rgba(0,0,0,.06);
}
textarea,input,select {
  width:100%;
  padding:8px;
  margin:6px 0;
  border-radius:6px;
  border:1px solid #d9d9d9;
}
textarea { font-family:monospace; min-height:80px; }
button {
  background:#1677ff;
  color:#fff;
  border:none;
  padding:8px 14px;
  border-radius:6px;
  cursor:pointer;
}
button.danger { background:#ff4d4f; }
.inline { display:flex; gap:8px; }
.inline>* { flex:1; }
.node-item,.rule-item {
  background:#fafafa;
  border-radius:8px;
  padding:12px;
  margin-top:10px;
}
.output {
  background:#0f172a;
  color:#22c55e;
  border-radius:8px;
}
.small { font-size:12px; color:#666; }
</style>
</head>

<body>

<h1>ğŸ§© Dialer é“¾å¼èŠ‚ç‚¹ç”Ÿæˆå™¨ Pro</h1>

<div class="section">
<h2>â‘  æ‰¹é‡ç²˜è´´ SOCKS / Clash èŠ‚ç‚¹</h2>
<textarea id="bulkInput" placeholder="ç¤ºä¾‹ï¼š
109.197.21.16:63567:user:pass
jp242.kookeey.info:21350:7913e609:aff1bdaa
7913e609:aff1bdaa@jp242.kookeey.info:21350
socks5://user:pass@jp242.kookeey.info:21350
- {name: VLESS-TCP, server: 1.2.3.4, port: 443, type: vless, uuid: xxxx}
- {"name":"ç¾å›½1","server":"global.sta.711proxy.com","port":"30000","type":"socks5","username":"USER435510-ip-173.232.3.126","password":"78d5d7","udp":false}
æ³¨æ„:å†’å·ç”¨è‹±æ–‡è¾“å…¥æ³•çš„å†’å·
"></textarea>
<div class="inline">
  <button onclick="parseBulk(true)">é‡æ–°è§£æï¼ˆæ¸…ç©ºæ—§èŠ‚ç‚¹ï¼‰</button>
  <button onclick="parseBulk(false)">è¿½åŠ è§£æ</button>
</div>
</div>

<div class="section">
<h2>â‘ -â‘¡ æ‰¹é‡é»˜è®¤é…ç½®</h2>
<p class="small">æ–°è§£æçš„èŠ‚ç‚¹å°†è‡ªåŠ¨ç»§æ‰¿æ­¤é…ç½®ï¼Œå¯åœ¨èŠ‚ç‚¹åˆ—è¡¨ä¸­å•ç‹¬ä¿®æ”¹</p>
<div class="inline">
  <select id="defaultDialerSelect" onchange="updateDefaultDialer()">
    <option value="">é€‰æ‹©é»˜è®¤å‰ç½®ä»£ç†</option>
  </select>
  <input id="defaultDialerManual" placeholder="æ‰‹åŠ¨è¾“å…¥é»˜è®¤å‰ç½®ä»£ç†ï¼ˆä¼˜å…ˆçº§æ›´é«˜ï¼‰" onchange="updateDefaultDialer()">
</div>
<label style="display:flex; align-items:center; margin-top:10px; gap:8px;">
  <input type="checkbox" id="advancedMode" onchange="toggleAdvancedMode()">
  <span>âš™ï¸ å¯ç”¨é«˜çº§æ¨¡å¼ï¼ˆä»£ç†ç»„ç®¡ç†ï¼‰</span>
</label>
<div id="advancedGroupSection" style="display:none; margin-top:10px;">
  <label style="display:flex; align-items:center; gap:8px;">
    <input type="checkbox" id="autoGenerateGroups" onchange="renderNodes()">
    <span>è‡ªåŠ¨ä¸ºæ¯ä¸ªèŠ‚ç‚¹ç”Ÿæˆä¸€ä¸ªä»£ç†ç»„</span>
  </label>
</div>
</div>

<div class="section">
<h2>â‘¡ èŠ‚ç‚¹åˆ—è¡¨ï¼ˆå¯æ”¹å + å‰ç½®ä»£ç†ï¼‰</h2>
<div style="background:#f0f2f5; padding:12px; border-radius:8px; margin-bottom:15px;">
  <h3 style="margin-top:0; margin-bottom:10px; font-size:14px;">æ‰¹é‡èŠ‚ç‚¹å‘½å</h3>
  <div class="inline">
    <input id="batchRenamePrefix" placeholder="èŠ‚ç‚¹åå‰ç¼€ï¼ˆä¾‹å¦‚ï¼šJP-ä½å®…-ï¼‰">
    <input type="number" id="batchRenameStart" placeholder="èµ·å§‹ç¼–å·" value="1" min="1">
    <button onclick="applyBatchRename()">åº”ç”¨åˆ°æ‰€æœ‰èŠ‚ç‚¹</button>
  </div>
</div>
<div id="nodeList"></div>
</div>

<div class="section">
<h2>â‘¢ SRC-IP è§„åˆ™</h2>
<p class="small">è§„åˆ™ç›®æ ‡é»˜è®¤ä½¿ç”¨èŠ‚ç‚¹åç§°ï¼Œå¯ç›´æ¥åœ¨ Clash Meta ä¸­ä½¿ç”¨</p>
<div class="inline">
<input id="r_ip" placeholder="192.168.100.2">
<select id="r_mask"><option>/32</option><option>/24</option></select>
<select id="r_target_select" onchange="updateRuleTarget()">
  <option value="">é€‰æ‹©èŠ‚ç‚¹</option>
</select>
<input id="r_target" placeholder="æˆ–æ‰‹åŠ¨è¾“å…¥èŠ‚ç‚¹åç§°/ä»£ç†ç»„å" onchange="updateRuleTargetSelect()">
</div>
<div id="advancedRuleSection" style="display:none; margin-top:8px;">
  <p class="small" style="color:#999;">é«˜çº§æ¨¡å¼ï¼šå¯é€‰æ‹©ä»£ç†ç»„ä½œä¸ºç›®æ ‡</p>
</div>
<button onclick="addRule()">æ·»åŠ è§„åˆ™</button>
<div id="ruleList"></div>

<h3 style="margin-top:20px; margin-bottom:10px;">æ‰¹é‡ SRC-IP ç”Ÿæˆ</h3>
<p class="small">ä¸€æ¬¡æ€§ç”Ÿæˆå¤šæ¡ SRC-IP è§„åˆ™</p>
<div class="inline">
<input id="batch_start_ip" placeholder="èµ·å§‹ IPï¼ˆå¦‚ 192.168.100.2ï¼‰">
<input type="number" id="batch_count" placeholder="æ•°é‡ï¼ˆå¦‚ 10ï¼‰" min="1" value="1">
<select id="batch_mask"><option>/32</option><option>/24</option></select>
</div>
<div class="inline" style="margin-top:8px;">
<label style="display:flex; align-items:center; gap:8px; flex:1;">
  <input type="radio" name="batch_mode" value="sequential" checked>
  <span>é¡ºåºç»‘å®šèŠ‚ç‚¹</span>
</label>
<label style="display:flex; align-items:center; gap:8px; flex:1;">
  <input type="radio" name="batch_mode" value="single">
  <span>ç»Ÿä¸€ç»‘å®šç›®æ ‡</span>
</label>
</div>
<input id="batch_single_target" placeholder="ç»Ÿä¸€ç›®æ ‡åç§°ï¼ˆèŠ‚ç‚¹åæˆ–ä»£ç†ç»„åï¼‰" style="margin-top:8px; display:none;">
<button onclick="addBatchRules()" style="margin-top:8px;">æ‰¹é‡ç”Ÿæˆè§„åˆ™</button>
</div>

<div class="section">
<h2>â‘£ Dialer èŠ‚ç‚¹ï¼ˆClash proxiesï¼‰</h2>
<textarea id="outNodes" class="output"></textarea>
<button onclick="copyText('outNodes')">å¤åˆ¶</button>
</div>

<div class="section">
<h2>â‘¤ èŠ‚ç‚¹åç§°åˆ—è¡¨</h2>
<textarea id="outNames" class="output"></textarea>
<button onclick="copyText('outNames')">å¤åˆ¶</button>
</div>

<div class="section">
<h2>â‘¥ SRC-IP è§„åˆ™è¾“å‡º</h2>
<textarea id="outRules" class="output"></textarea>
<button onclick="copyText('outRules')">å¤åˆ¶</button>
</div>

<div class="section" id="groupsSection" style="display:none;">
<h2>â‘¦ ä»£ç†ç»„é…ç½®ï¼ˆproxy-groupsï¼‰</h2>
<p class="small">ä»…åœ¨å¯ç”¨é«˜çº§æ¨¡å¼æ—¶æ˜¾ç¤º</p>
<textarea id="outGroups" class="output"></textarea>
<button onclick="copyText('outGroups')">å¤åˆ¶</button>
</div>

<button onclick="generate()">ğŸš€ ç”Ÿæˆå…¨éƒ¨</button>

<script>
let nodes = [];
let rules = [];
let idx = 1;
let groupIdx = 1; // ä»£ç†ç»„åºå·è®¡æ•°å™¨

// æ‰¹é‡é»˜è®¤é…ç½®
let defaultDialer = ""; // é»˜è®¤å‰ç½®ä»£ç†ï¼ˆä»ä¸‹æ‹‰æ¡†æˆ–æ‰‹åŠ¨è¾“å…¥è·å–ï¼‰

const dialers = ["ğŸ‡­ğŸ‡° é¦™æ¸¯èŠ‚ç‚¹","ğŸ‡¸ğŸ‡¬ ç‹®åŸèŠ‚ç‚¹","ğŸ‡¯ğŸ‡µ æ—¥æœ¬èŠ‚ç‚¹","ğŸ‡ºğŸ‡² ç¾å›½èŠ‚ç‚¹","ğŸ‡¨ğŸ‡³ å°æ¹¾èŠ‚ç‚¹","ç­–ç•¥1","ç­–ç•¥2"];

// åˆ‡æ¢é«˜çº§æ¨¡å¼
function toggleAdvancedMode() {
  const advancedMode = document.getElementById("advancedMode").checked;
  const advancedGroupSection = document.getElementById("advancedGroupSection");
  const advancedRuleSection = document.getElementById("advancedRuleSection");
  const groupsSection = document.getElementById("groupsSection");
  
  if (advancedMode) {
    advancedGroupSection.style.display = "block";
    advancedRuleSection.style.display = "block";
    groupsSection.style.display = "block";
  } else {
    advancedGroupSection.style.display = "none";
    advancedRuleSection.style.display = "none";
    groupsSection.style.display = "none";
    // å…³é—­è‡ªåŠ¨ç”Ÿæˆä»£ç†ç»„
    document.getElementById("autoGenerateGroups").checked = false;
  }
  
  renderNodes();
  updateRuleTargetSelectOptions();
}

function uniqueName(base){
  let name = base, i = 1;
  while(nodes.some(n=>n.name===name)) name = base+"-"+i++;
  return name;
}

// ç”Ÿæˆå”¯ä¸€çš„ä»£ç†ç»„åç§°
function uniqueGroupName(base){
  // å¦‚æœ base æ˜¯ "ç­–ç•¥1" è¿™æ ·çš„æ ¼å¼ï¼Œæå–æ•°å­—éƒ¨åˆ†
  const match = base.match(/^(.+?)(\d+)$/);
  if (match) {
    const prefix = match[1]; // "ç­–ç•¥"
    let num = parseInt(match[2]); // 1
    let name = base;
    while(nodes.some(n=>n.groupName===name)) {
      num++;
      name = prefix + num;
    }
    return name;
  }
  // å¦‚æœä¸æ˜¯æ•°å­—ç»“å°¾ï¼Œä½¿ç”¨åŸæ¥çš„é€»è¾‘
  let name = base, i = 1;
  while(nodes.some(n=>n.groupName===name)) name = base + "-" + i++;
  return name;
}

// è·å–æ‰¹é‡é»˜è®¤å‰ç½®ä»£ç†é…ç½®ï¼ˆç»Ÿä¸€æ•°æ®æºï¼‰
function getDefaultDialer(){
  const manual = document.getElementById("defaultDialerManual")?.value?.trim() || "";
  const select = document.getElementById("defaultDialerSelect")?.value?.trim() || "";
  return manual || select || "";
}

// æ›´æ–°é»˜è®¤å‰ç½®ä»£ç†é…ç½®
function updateDefaultDialer(){
  const manual = document.getElementById("defaultDialerManual").value.trim();
  const select = document.getElementById("defaultDialerSelect").value;
  // æ‰‹åŠ¨è¾“å…¥ä¼˜å…ˆçº§æ›´é«˜
  defaultDialer = manual || select || "";
}

// æ›´æ–°è§„åˆ™ç›®æ ‡é€‰æ‹©ä¸‹æ‹‰æ¡†
function updateRuleTargetSelect(){
  const select = document.getElementById("r_target_select");
  const input = document.getElementById("r_target");
  // å¦‚æœæ‰‹åŠ¨è¾“å…¥äº†ï¼Œæ¸…ç©ºä¸‹æ‹‰é€‰æ‹©
  if(input.value.trim()) {
    select.value = "";
  }
}

// æ›´æ–°è§„åˆ™ç›®æ ‡è¾“å…¥æ¡†
function updateRuleTarget(){
  const select = document.getElementById("r_target_select");
  const input = document.getElementById("r_target");
  // å¦‚æœé€‰æ‹©äº†ä¸‹æ‹‰æ¡†ï¼Œå¡«å……åˆ°è¾“å…¥æ¡†
  if(select.value) {
    input.value = select.value;
  }
}

// åˆå§‹åŒ–é»˜è®¤å‰ç½®ä»£ç†ä¸‹æ‹‰æ¡†
function initDefaultDialerSelect(){
  const select = document.getElementById("defaultDialerSelect");
  select.innerHTML = '<option value="">é€‰æ‹©é»˜è®¤å‰ç½®ä»£ç†</option>';
  dialers.forEach(d => {
    select.innerHTML += `<option value="${d}">${d}</option>`;
  });
}

// æ›´æ–°è§„åˆ™ç›®æ ‡ä¸‹æ‹‰æ¡†ï¼ˆé»˜è®¤æ˜¾ç¤ºèŠ‚ç‚¹åç§°ï¼Œé«˜çº§æ¨¡å¼å¯æ˜¾ç¤ºä»£ç†ç»„ï¼‰
function updateRuleTargetSelectOptions(){
  const select = document.getElementById("r_target_select");
  const currentValue = select.value;
  const advancedMode = document.getElementById("advancedMode")?.checked || false;
  
  select.innerHTML = '<option value="">é€‰æ‹©èŠ‚ç‚¹</option>';
  
  // é»˜è®¤æ˜¾ç¤ºæ‰€æœ‰èŠ‚ç‚¹åç§°
  nodes.forEach(n => {
    select.innerHTML += `<option value="${n.name}">èŠ‚ç‚¹: ${n.name}</option>`;
  });
  
  // é«˜çº§æ¨¡å¼ï¼šåŒæ—¶æ˜¾ç¤ºä»£ç†ç»„åç§°
  if (advancedMode) {
    const groupNames = [...new Set(nodes.map(n => n.groupName).filter(Boolean))];
    groupNames.forEach(name => {
      select.innerHTML += `<option value="${name}">ä»£ç†ç»„: ${name}</option>`;
    });
  }
  
  // æ¢å¤ä¹‹å‰çš„é€‰æ‹©
  if(currentValue) {
    const optionExists = Array.from(select.options).some(opt => opt.value === currentValue);
    if(optionExists) {
      select.value = currentValue;
    }
  }
}

function isSocks(line) {
  const s = line.trim();

  // BUG 2 ä¿®å¤ï¼šsocks5:// å’Œ socks:// å¿…é¡»æœ€ä¼˜å…ˆåˆ¤æ–­ï¼Œä½¿ç”¨ startsWith
  if (s.toLowerCase().startsWith('socks5://') || s.toLowerCase().startsWith('socks://')) {
    return true;
  }

  // user:pass@host:port
  if (/^[^:@\s]+:[^@\s]+@[a-zA-Z0-9.-]+:\d{2,5}$/.test(s)) return true;

  // host:port æˆ– host:port:user:passï¼ˆhost æ”¯æŒåŸŸå/IPï¼‰
  if (/^[a-zA-Z0-9.-]+:\d{2,5}(:[^:\s]+(:[^:\s]+)?)?$/.test(s)) return true;

  return false;
}

function parseSocksLine(line) {
  const s = line.trim();
  
  // BUG 2 ä¿®å¤ï¼šsocks5:// å’Œ socks:// çš„è§£æé€»è¾‘å¿…é¡»æ”¾åœ¨å‡½æ•°ç¬¬ä¸€æ®µ
  // ä¼˜å…ˆä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼è§£æï¼Œæ›´å¯é 
  if (s.toLowerCase().startsWith('socks5://') || s.toLowerCase().startsWith('socks://')) {
    // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼ç›´æ¥è§£æï¼šsocks5://[user:pass@]host:port
    // åŒ¹é…æ ¼å¼ï¼šsocks5://user:pass@host:port æˆ– socks5://host:port
    // æ”¯æŒåŸŸåã€IPåœ°å€ï¼Œä»¥åŠåŒ…å«è¿å­—ç¬¦çš„åŸŸå
    const regexMatch = s.match(/^socks5?:\/\/(?:([^:@\s]+):([^@\s]+)@)?([a-zA-Z0-9.\-]+):(\d{2,5})/i);
    if (regexMatch && regexMatch[3] && regexMatch[4]) {
      return {
        user: regexMatch[1] ? decodeURIComponent(regexMatch[1]) : "",
        pass: regexMatch[2] ? decodeURIComponent(regexMatch[2]) : "",
        server: regexMatch[3],
        port: regexMatch[4],
        remark: ""
      };
    }
    
    // å¦‚æœæ­£åˆ™å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨ URL APIï¼ˆä½œä¸ºå¤‡ç”¨æ–¹æ¡ˆï¼‰
    try {
      const u = new URL(s);
      const hostname = u.hostname || "";
      let port = u.port || "";
      
      // å¦‚æœ port ä¸ºç©ºï¼Œä» host ä¸­æå–
      if (!port && u.host) {
        const hostMatch = u.host.match(/:(\d{2,5})$/);
        if (hostMatch) {
          port = hostMatch[1];
        }
      }
      
      // å¦‚æœè¿˜æ˜¯æ²¡æœ‰ï¼Œä»åŸå§‹å­—ç¬¦ä¸²ä¸­æå–
      if (!port) {
        const portMatch = s.match(/:(\d{2,5})(?:\/|$|#)/);
        if (portMatch) {
          port = portMatch[1];
        }
      }
      
      if (hostname && port) {
        return {
          user: u.username ? decodeURIComponent(u.username) : "",
          pass: u.password ? decodeURIComponent(u.password) : "",
          server: hostname,
          port: port,
          remark: ""
        };
      }
    } catch (e) {
      // URL è§£æå¤±è´¥ï¼Œç»§ç»­æ‰§è¡Œä¸‹é¢çš„é€»è¾‘
    }
  }

  // å¯¹å…¶ä»–æ ¼å¼è¿›è¡Œæ¸…æ´—å¤„ç†
  const clean = s.replace(/\{.+?\}|#.+$/, "");

  // â‘  user:pass@host:port
  const m = clean.match(/^([^:@\s]+):([^@\s]+)@([^:\s]+):(\d{2,5})$/);
  if (m) {
    return { user: m[1], pass: m[2], server: m[3], port: m[4], remark: "" };
  }

  // â‘¡ host:port[:user[:pass]]
  const parts = clean.split(":");
  return {
    server: parts[0],
    port: parts[1],
    user: parts[2] || "",
    pass: parts[3] || "",
    remark: ""
  };
}

function isClash(line){
  const trimmed = line.trim();
  // æ”¯æŒä¸¤ç§æ ¼å¼ï¼š
  // 1. YAML é£æ ¼ï¼š- {name: xxx, type: xxx, ...}
  // 2. JSON é£æ ¼ï¼š- {"name":"xxx","type":"xxx",...}
  return trimmed.startsWith("- {") && (trimmed.includes("type:") || trimmed.includes('"type"'));
}

function parseBulk(reset){
  if (reset) {
    nodes = [];
    idx = 1;
    groupIdx = 1; // é‡ç½®ä»£ç†ç»„åºå·
  }

  // è·å–æ‰¹é‡é»˜è®¤å‰ç½®ä»£ç†é…ç½®ï¼ˆç»Ÿä¸€ä½¿ç”¨ getDefaultDialer()ï¼‰
  const dft = getDefaultDialer();

  // æ£€æŸ¥æ˜¯å¦å¯ç”¨è‡ªåŠ¨ç”Ÿæˆä»£ç†ç»„
  const autoGenGroups = document.getElementById("autoGenerateGroups").checked;

  bulkInput.value
    .split("\n")
    .map(l => l.trim())
    .filter(Boolean)
    .forEach(line => {

      if (isSocks(line)) {
        const s = parseSocksLine(line);

        // ç”Ÿæˆä»£ç†ç»„åç§°ï¼ˆå¦‚æœå¯ç”¨ï¼‰
        const groupName = autoGenGroups ? uniqueGroupName("ç­–ç•¥" + groupIdx++) : "";

        nodes.push({
          type: "socks",
          name: uniqueName("SOCKS-" + idx++),
          server: s.server,   // âœ… ç»Ÿä¸€ç”¨ server
          port: s.port,
          user: s.user,
          pass: s.pass,
          dialer: dft, // åº”ç”¨é»˜è®¤å‰ç½®ä»£ç†
          groupName: groupName // ä»£ç†ç»„åç§°
        });
        return;
      }

      if (isClash(line)) {
        let nodeName = `CLASH-${idx++}`;
        
        // å°è¯•è§£æä¸º JSON æ ¼å¼ï¼ˆå¸¦å¼•å·ï¼‰
        try {
          // æå– - { ... } ä¸­çš„ JSON éƒ¨åˆ†
          const jsonMatch = line.match(/^-\s*(\{.+\})/);
          if (jsonMatch) {
            const jsonStr = jsonMatch[1];
            const obj = JSON.parse(jsonStr);
            if (obj.name) {
              nodeName = obj.name;
            }
          }
        } catch (e) {
          // JSON è§£æå¤±è´¥ï¼Œå°è¯•æ­£åˆ™åŒ¹é…ï¼ˆYAML é£æ ¼ï¼šname: xxx æˆ– "name": "xxx"ï¼‰
          // æ”¯æŒä¸¤ç§æ ¼å¼ï¼š
          // 1. name: xxx (YAML é£æ ¼ï¼Œå¯èƒ½å¸¦å¼•å·)
          // 2. "name": "xxx" (JSON é£æ ¼)
          const m1 = line.match(/"name"\s*:\s*"([^"]+)"/); // JSON é£æ ¼ï¼š"name": "xxx"
          const m2 = line.match(/name\s*:\s*([^,}]+)/); // YAML é£æ ¼ï¼šname: xxx
          const m = m1 || m2;
          if (m) {
            nodeName = m[1].trim().replace(/^["']|["']$/g, ''); // å»é™¤å¯èƒ½çš„å¼•å·
          }
        }
        
        // ç”Ÿæˆä»£ç†ç»„åç§°ï¼ˆå¦‚æœå¯ç”¨ï¼‰
        const groupName = autoGenGroups ? uniqueGroupName("ç­–ç•¥" + groupIdx++) : "";

        nodes.push({
          type: "clash",
          name: uniqueName(nodeName),
          raw: line,
          dialer: dft, // åº”ç”¨é»˜è®¤å‰ç½®ä»£ç†
          groupName: groupName // ä»£ç†ç»„åç§°
        });
      }
    });

  renderNodes();
  updateRuleTargetSelectOptions(); // æ›´æ–°è§„åˆ™ç›®æ ‡ä¸‹æ‹‰æ¡†
}

// æ‰¹é‡é‡å‘½åèŠ‚ç‚¹
function batchRenameNodes(prefix, start = 1) {
  let i = start;
  nodes.forEach(n => {
    n.name = `${prefix}${i++}`;
  });
  renderNodes();
  updateRuleTargetSelectOptions();
}

// åº”ç”¨æ‰¹é‡é‡å‘½å
function applyBatchRename() {
  const prefix = document.getElementById("batchRenamePrefix").value.trim();
  const start = parseInt(document.getElementById("batchRenameStart").value) || 1;
  
  if (!prefix) {
    alert("è¯·å¡«å†™èŠ‚ç‚¹åå‰ç¼€");
    return;
  }
  
  if (nodes.length === 0) {
    alert("æ²¡æœ‰å¯é‡å‘½åçš„èŠ‚ç‚¹");
    return;
  }
  
  batchRenameNodes(prefix, start);
}

function renderNodes(){
  nodeList.innerHTML="";
  const advancedMode = document.getElementById("advancedMode")?.checked || false;
  const autoGenGroups = document.getElementById("autoGenerateGroups")?.checked || false;
  
  nodes.forEach((n,i)=>{
    // ç¡®ä¿ groupName å­—æ®µå­˜åœ¨
    if(!n.groupName) n.groupName = "";
    // ç¡®ä¿ dialer å­—æ®µå­˜åœ¨ä¸”ä¸ä¼šè¢«æ„å¤–æ¸…ç©ºï¼ˆä¿æŠ¤æ‰¹é‡é»˜è®¤å‰ç½®ä»£ç†ï¼‰
    // æ³¨æ„ï¼šè¿™é‡Œä¸åˆå§‹åŒ– dialerï¼Œåªåœ¨ parseBulk() æˆ–ç”¨æˆ·æ˜ç¡®è¾“å…¥æ—¶è®¾ç½®
    
    nodeList.innerHTML+=`
    <div class="node-item">
      <div style="margin-bottom:8px;">
        <label style="font-size:12px; color:#666;">èŠ‚ç‚¹åç§°ï¼š</label>
        <input value="${n.name}" onchange="nodes[${i}].name=this.value; updateRuleTargetSelectOptions();">
      </div>
      <div class="inline" style="margin-bottom:8px;">
        <select value="${n.dialer || ''}" onchange="
          if (this.value.trim() !== '') {
            nodes[${i}].dialer = this.value.trim();
          }
        ">
          <option value="">é€‰æ‹©å‰ç½®</option>
          ${dialers.map(d=>`<option value="${d}" ${(n.dialer && n.dialer.trim() === d) ? 'selected' : ''}>${d}</option>`).join("")}
        </select>
        <input placeholder="æ‰‹åŠ¨è¾“å…¥å‰ç½®ä»£ç†" value="${n.dialer || ''}" onchange="
          if (this.value.trim() !== '') {
            nodes[${i}].dialer = this.value.trim();
          }
        ">
      </div>
      ${(advancedMode && autoGenGroups) ? `
      <div style="margin-bottom:8px;">
        <label style="font-size:12px; color:#666;">ä»£ç†ç»„åç§°ï¼š</label>
        <input value="${n.groupName || ''}" placeholder="ç­–ç•¥1" onchange="nodes[${i}].groupName=this.value; updateRuleTargetSelectOptions();">
      </div>
      ` : ''}
      <button class="danger" onclick="nodes.splice(${i},1);renderNodes(); updateRuleTargetSelectOptions();">åˆ é™¤èŠ‚ç‚¹</button>
    </div>`;
  });
  
  // æ›´æ–°è§„åˆ™ç›®æ ‡ä¸‹æ‹‰æ¡†
  updateRuleTargetSelectOptions();
}

function addRule(){
  const targetValue = document.getElementById("r_target").value.trim();
  if(!targetValue) {
    alert("è¯·å¡«å†™èŠ‚ç‚¹åç§°æˆ–ä»£ç†ç»„å");
    return;
  }
  rules.push({ip:r_ip.value,mask:r_mask.value,group:targetValue});
  renderRules();
  // æ¸…ç©ºè¾“å…¥
  document.getElementById("r_ip").value = "";
  document.getElementById("r_target").value = "";
  document.getElementById("r_target_select").value = "";
}

function renderRules(){
  ruleList.innerHTML="";
  rules.forEach((r,i)=>{
    ruleList.innerHTML+=`
    <div class="rule-item">
      ${r.ip}${r.mask} â†’ ${r.group}
      <button class="danger" onclick="rules.splice(${i},1);renderRules()">åˆ é™¤</button>
    </div>`;
  });
}

// æ‰¹é‡ç”Ÿæˆ SRC-IP è§„åˆ™
function addBatchRules(){
  const startIP = document.getElementById("batch_start_ip").value.trim();
  const count = parseInt(document.getElementById("batch_count").value) || 1;
  const mask = document.getElementById("batch_mask").value;
  const mode = document.querySelector('input[name="batch_mode"]:checked').value;
  
  if(!startIP) {
    alert("è¯·å¡«å†™èµ·å§‹ IP");
    return;
  }
  
  // éªŒè¯ IP æ ¼å¼
  const ipRegex = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
  const match = startIP.match(ipRegex);
  if(!match) {
    alert("IP æ ¼å¼ä¸æ­£ç¡®");
    return;
  }
  
  // é»˜è®¤ä½¿ç”¨èŠ‚ç‚¹åç§°åˆ—è¡¨ï¼ˆä¸å†å¼ºåˆ¶è¦æ±‚ä»£ç†ç»„ï¼‰
  const nodeNames = nodes.map(n => n.name);
  if(mode === "sequential" && nodeNames.length === 0) {
    alert("æ²¡æœ‰å¯ç”¨çš„èŠ‚ç‚¹ï¼Œè¯·å…ˆè§£æèŠ‚ç‚¹");
    return;
  }
  
  // è§£æèµ·å§‹ IP çš„å››ä¸ªæ®µ
  let ip1 = parseInt(match[1]);
  let ip2 = parseInt(match[2]);
  let ip3 = parseInt(match[3]);
  let ip4 = parseInt(match[4]);
  
  // éªŒè¯ IP æ®µèŒƒå›´
  if(ip1 > 255 || ip2 > 255 || ip3 > 255 || ip4 > 255) {
    alert("IP åœ°å€æ®µè¶…å‡ºèŒƒå›´ï¼ˆ0-255ï¼‰");
    return;
  }
  
  // ç»Ÿä¸€ç»‘å®šæ¨¡å¼ï¼šæå‰è·å–ç›®æ ‡åç§°
  let singleTargetName = "";
  if(mode === "single") {
    singleTargetName = document.getElementById("batch_single_target").value.trim();
    if(!singleTargetName) {
      alert("è¯·å¡«å†™ç»Ÿä¸€ç›®æ ‡åç§°ï¼ˆèŠ‚ç‚¹åæˆ–ä»£ç†ç»„åï¼‰");
      return;
    }
  }
  
  // ç”Ÿæˆè§„åˆ™
  for(let i = 0; i < count; i++) {
    // è®¡ç®—å½“å‰ IPï¼ˆä»èµ·å§‹ IP å¼€å§‹é€’å¢ï¼‰
    let currentIP1 = ip1;
    let currentIP2 = ip2;
    let currentIP3 = ip3;
    let currentIP4 = ip4 + i; // ä»èµ·å§‹ IP çš„ç¬¬ 4 æ®µå¼€å§‹é€’å¢
    
    // å¤„ç† IP æ®µæº¢å‡ºï¼ˆä»ä½ä½åˆ°é«˜ä½è¿›ä½ï¼‰
    while(currentIP4 > 255) {
      currentIP4 -= 256;
      currentIP3++;
    }
    while(currentIP3 > 255) {
      currentIP3 -= 256;
      currentIP2++;
    }
    while(currentIP2 > 255) {
      currentIP2 -= 256;
      currentIP1++;
    }
    if(currentIP1 > 255) {
      alert(`IP è¶…å‡ºèŒƒå›´ï¼š${currentIP1}.${currentIP2}.${currentIP3}.${currentIP4}`);
      break;
    }
    
    const currentIP = `${currentIP1}.${currentIP2}.${currentIP3}.${currentIP4}`;
    
    // ç¡®å®šç›®æ ‡åç§°ï¼ˆé»˜è®¤ä½¿ç”¨èŠ‚ç‚¹åç§°ï¼‰
    let targetName;
    if(mode === "sequential") {
      // é¡ºåºç»‘å®šï¼šèŠ‚ç‚¹1 â†’ èŠ‚ç‚¹2 â†’ èŠ‚ç‚¹3...
      targetName = nodeNames[i % nodeNames.length] || `èŠ‚ç‚¹${(i % nodeNames.length) + 1}`;
    } else {
      // ç»Ÿä¸€ç»‘å®š
      targetName = singleTargetName;
    }
    
    // æ·»åŠ åˆ°è§„åˆ™åˆ—è¡¨
    rules.push({
      ip: currentIP,
      mask: mask,
      group: targetName
    });
  }
  
  renderRules();
  updateRuleTargetSelectOptions(); // æ›´æ–°è§„åˆ™ç›®æ ‡ä¸‹æ‹‰æ¡†
  
  // æ¸…ç©ºè¾“å…¥
  document.getElementById("batch_start_ip").value = "";
  document.getElementById("batch_count").value = "1";
}

function generate(){
  const indent = "  ";

  // ç”Ÿæˆ Dialer èŠ‚ç‚¹ï¼ˆClash proxiesï¼‰
  const dft = getDefaultDialer(); // è·å–æ‰¹é‡é»˜è®¤å‰ç½®ä»£ç†
  outNodes.value = nodes.map(n => {
    // SOCKS èŠ‚ç‚¹ï¼šå§‹ç»ˆç”Ÿæˆ udp:true
    if (n.type === "socks") {
      // dialer-proxy çš„ä¼˜å…ˆçº§ï¼šèŠ‚ç‚¹æœ¬èº« n.dialerï¼ˆåŒ…æ‹¬æ‰¹é‡é»˜è®¤å‰ç½® or å•ç‹¬ä¿®æ”¹ï¼‰ > æ‰¹é‡é»˜è®¤å‰ç½® > ä¸è¾“å‡º
      const dialerFinal = (n.dialer && n.dialer.trim()) ? n.dialer.trim() : dft;
      const dialerPart = dialerFinal ? `, dialer-proxy: ${dialerFinal}` : "";
      return indent + `- {name: ${n.name}, type: socks5, server: ${n.server}, port: ${n.port}, username: "${n.user}", password: "${n.pass}", udp: true${dialerPart}}`;
    }

    // Clash èŠ‚ç‚¹ï¼šéœ€è¦åˆ¤æ–­ udp æ˜¯å¦å·²å­˜åœ¨
    let raw = n.raw;
    let isJsonFormat = false;

    // æ£€æµ‹æ˜¯å¦ä¸º JSON æ ¼å¼ï¼ˆå¸¦å¼•å·ï¼‰
    try {
      const jsonMatch = raw.match(/^-\s*(\{.+\})/);
      if (jsonMatch) {
        const jsonStr = jsonMatch[1];
        JSON.parse(jsonStr); // éªŒè¯æ˜¯å¦ä¸ºæœ‰æ•ˆ JSON
        isJsonFormat = true;
      }
    } catch (e) {
      // ä¸æ˜¯ JSON æ ¼å¼ï¼Œç»§ç»­ä½¿ç”¨ YAML å¤„ç†
    }

    if (isJsonFormat) {
      // JSON æ ¼å¼ï¼šè§£æåé‡æ–°æ„å»ºä¸º YAML æ ¼å¼ï¼ˆClash é…ç½®é€šå¸¸ä½¿ç”¨ YAMLï¼‰
      try {
        const jsonMatch = raw.match(/^-\s*(\{.+\})/);
        if (jsonMatch) {
          const jsonStr = jsonMatch[1];
          const obj = JSON.parse(jsonStr);
          
          // æ›´æ–° name
          obj.name = n.name;
          
          // å¦‚æœæ²¡æœ‰ udp å­—æ®µï¼Œæ·»åŠ  udp: true
          if (obj.udp === undefined) {
            obj.udp = true;
          }
          
          // æ·»åŠ æˆ–æ›´æ–° dialer-proxy
          const dialerFinal = (n.dialer && n.dialer.trim()) ? n.dialer.trim() : dft;
          if (dialerFinal) {
            obj["dialer-proxy"] = dialerFinal;
          }
          
          // è½¬æ¢ä¸º YAML æ ¼å¼å­—ç¬¦ä¸²
          const yamlPairs = [];
          for (const [key, value] of Object.entries(obj)) {
            if (value === null || value === undefined) {
              continue; // è·³è¿‡ null å’Œ undefined
            } else if (typeof value === "boolean") {
              yamlPairs.push(`${key}: ${value}`);
            } else if (typeof value === "number") {
              yamlPairs.push(`${key}: ${value}`);
            } else if (typeof value === "string") {
              // å­—ç¬¦ä¸²å€¼ï¼šå¦‚æœåŒ…å«ç©ºæ ¼ã€å†’å·ã€é€—å·ç­‰ç‰¹æ®Šå­—ç¬¦ï¼Œéœ€è¦åŠ å¼•å·
              if (value.includes(" ") || value.includes(":") || value.includes(",") || value.includes("@")) {
                yamlPairs.push(`${key}: "${value}"`);
              } else {
                yamlPairs.push(`${key}: ${value}`);
              }
            } else {
              // å…¶ä»–ç±»å‹ï¼ˆå¦‚æ•°ç»„ã€å¯¹è±¡ï¼‰è½¬ä¸ºå­—ç¬¦ä¸²
              yamlPairs.push(`${key}: ${JSON.stringify(value)}`);
            }
          }
          raw = `- {${yamlPairs.join(", ")}}`;
        }
      } catch (e) {
        // JSON è§£æå¤±è´¥ï¼Œå›é€€åˆ°æ­£åˆ™å¤„ç†
        isJsonFormat = false;
      }
    }

    if (!isJsonFormat) {
      // YAML æ ¼å¼å¤„ç†ï¼ˆåŸæœ‰é€»è¾‘ï¼‰
      // â‘  ç»Ÿä¸€ nameï¼šæœ€ç»ˆè¾“å‡ºçš„ name å¿…é¡»æ¥è‡ª n.nameï¼Œè€Œä¸æ˜¯åŸå§‹ raw
      //    a) åˆ é™¤åŸæœ‰çš„ name å­—æ®µï¼ˆæ”¯æŒä¸¤ç§æ ¼å¼ï¼šname: xxx å’Œ "name": "xxx"ï¼‰
      raw = raw.replace(/"name"\s*:\s*"[^"]*",?\s*/g, ""); // JSON é£æ ¼
      raw = raw.replace(/\bname\s*:\s*[^,}]+,?\s*/g, ""); // YAML é£æ ¼
      //    b) åœ¨æœ€å‰é¢æ’å…¥æ–°çš„ name å­—æ®µ
      raw = raw.replace(/^\s*-\s*\{/, `- {name: ${n.name}, `);

      // â‘¡ å¦‚æœåŸèŠ‚ç‚¹é‡Œæ²¡æœ‰ udp å­—æ®µï¼Œæ‰è¡¥ udp:trueï¼ˆé¿å…é‡å¤è¿½åŠ ï¼‰
      if (!/\budp\s*:/.test(raw)) {
        raw = raw.replace(/\}$/, `, udp: true}`);
      }

      // â‘¢ è¿½åŠ  dialer-proxyï¼ˆå¦‚æœå­˜åœ¨ï¼‰ï¼šèŠ‚ç‚¹æœ¬èº« n.dialer > æ‰¹é‡é»˜è®¤å‰ç½® > ä¸è¾“å‡º
      const dialerFinal = (n.dialer && n.dialer.trim()) ? n.dialer.trim() : dft;
      if (dialerFinal) {
        // æ£€æŸ¥æ˜¯å¦å·²ç»åŒ…å« dialer-proxyï¼Œé¿å…é‡å¤
        if (!/\bdialer-proxy\s*:/.test(raw)) {
          raw = raw.replace(/\}$/, `, dialer-proxy: ${dialerFinal}}`);
        } else {
          // å¦‚æœå·²å­˜åœ¨ï¼Œæ›¿æ¢å®ƒ
          raw = raw.replace(/\bdialer-proxy\s*:[^,}]+/, `dialer-proxy: ${dialerFinal}`);
        }
      }
    }

    return indent + raw;
  }).join("\n");

  // ç”ŸæˆèŠ‚ç‚¹åç§°åˆ—è¡¨
  outNames.value = nodes
    .map(n => indent + `- ${n.name}`)
    .join("\n");

  // ç”Ÿæˆ SRC-IP è§„åˆ™
  outRules.value = rules
    .map(r => indent + `- SRC-IP-CIDR,${r.ip}${r.mask},${r.group}`)
    .join("\n");

  // ç”Ÿæˆä»£ç†ç»„é…ç½®ï¼ˆä»…åœ¨é«˜çº§æ¨¡å¼ä¸”å¯ç”¨è‡ªåŠ¨ç”Ÿæˆæ—¶ï¼‰
  const advancedMode = document.getElementById("advancedMode")?.checked || false;
  const autoGenGroups = document.getElementById("autoGenerateGroups")?.checked || false;
  if (advancedMode && autoGenGroups) {
    // æŒ‰ä»£ç†ç»„åç§°åˆ†ç»„èŠ‚ç‚¹
    const groupMap = {};
    nodes.forEach(n => {
      const groupName = n.groupName || "ç­–ç•¥1"; // å¦‚æœæ²¡æœ‰è®¾ç½®ï¼Œä½¿ç”¨é»˜è®¤å€¼
      if (!groupMap[groupName]) {
        groupMap[groupName] = [];
      }
      groupMap[groupName].push(n.name);
    });

    // ç”Ÿæˆ proxy-groups é…ç½®ï¼ˆæ”¹ä¸ºç´§å‡‘çš„å•è¡Œ map æ ¼å¼ï¼‰
    outGroups.value = Object.keys(groupMap)
      .map(groupName => {
        // æ”¹ä¸ºå•è¡Œ map æ ¼å¼ï¼šproxies å¿…é¡»ä¿æŒæ¨ªå‘å•è¡Œæ•°ç»„
        const proxiesList = groupMap[groupName].join(", ");
        return `${indent}- {name: ${groupName}, type: select, proxies: [${proxiesList}]}`;
      })
      .join("\n");
  } else {
    outGroups.value = "";
  }
}
function copyText(id){
  const el = document.getElementById(id);
  if (!el) {
    alert("å¤åˆ¶å¤±è´¥ï¼šæ‰¾ä¸åˆ°å†…å®¹");
    return;
  }

  const text = el.value || el.innerText || "";

  if (!text) {
    alert("æ²¡æœ‰å¯å¤åˆ¶çš„å†…å®¹");
    return;
  }

  // ä½¿ç”¨ç°ä»£ Clipboard API
  navigator.clipboard.writeText(text).then(() => {
    // å¯é€‰ï¼šç»™ä¸€ç‚¹åé¦ˆ
    alert("å·²å¤åˆ¶åˆ°å‰ªè´´æ¿");
  }).catch(err => {
    console.error(err);
    alert("å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶");
  });
}

// é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
window.onload = function() {
  initDefaultDialerSelect(); // åˆå§‹åŒ–é»˜è®¤å‰ç½®ä»£ç†ä¸‹æ‹‰æ¡†
  updateRuleTargetSelectOptions(); // åˆå§‹åŒ–è§„åˆ™ç›®æ ‡ä¸‹æ‹‰æ¡†
  
  // æ‰¹é‡ç”Ÿæˆæ¨¡å¼åˆ‡æ¢ï¼šæ˜¾ç¤º/éšè—ç»Ÿä¸€ç›®æ ‡è¾“å…¥æ¡†
  document.querySelectorAll('input[name="batch_mode"]').forEach(radio => {
    radio.addEventListener('change', function() {
      const singleTargetInput = document.getElementById("batch_single_target");
      if(this.value === "single") {
        singleTargetInput.style.display = "block";
      } else {
        singleTargetInput.style.display = "none";
      }
    });
  });
};
</script>

</body>
</html>

